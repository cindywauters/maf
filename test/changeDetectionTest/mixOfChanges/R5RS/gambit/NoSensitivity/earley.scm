;; renamed lambdas/lets: 10
;; Of which consistent renamings: 6

(define make-parser (lambda (grammar lexer)
      (define non-terminals (lambda (grammar)
            (define add-nt (lambda (nt nts)
                  (if (member nt nts) nts (cons nt nts))))
            ((letrec ((def-loop (lambda (defs nts)
                                 (if (pair? defs)
                                    (let* ((def (car defs))
                                           (head (car def)))
                                       ((<change>
                                          (letrec ((rule-loop (lambda (rules nts)
                                                                (if (pair? rules)
                                                                   (let ((rule (car rules)))
                                                                      ((letrec ((loop (lambda (l nts)
                                                                                       (if (pair? l)
                                                                                          (let ((nt (car l)))
                                                                                             (loop (cdr l) (add-nt nt nts)))
                                                                                          (rule-loop (cdr rules) nts)))))
                                                                         loop)
                                                                         rule
                                                                         nts))
                                                                   (def-loop (cdr defs) nts)))))
                                             rule-loop)
                                          (letrec ((_rule-loop0 (lambda (_rules0 _nts0)
                                                                  (if (pair? _rules0)
                                                                     (let ((_rule0 (car _rules0)))
                                                                        ((letrec ((_loop0 (lambda (_l0 _nts1)
                                                                                           (if (pair? _l0)
                                                                                              (let ((_nt0 (car _l0)))
                                                                                                 (_loop0 (cdr _l0) (add-nt _nt0 _nts1)))
                                                                                              (_rule-loop0 (cdr _rules0) _nts1)))))
                                                                           _loop0)
                                                                           _rule0
                                                                           _nts0))
                                                                     (def-loop (cdr defs) _nts0)))))
                                             _rule-loop0))
                                          (cdr def)
                                          (add-nt head nts)))
                                    (list->vector (reverse nts))))))
               def-loop)
               grammar
               ())))
      (define ind (<change>
            (lambda (nt nts)
               ((letrec ((loop (lambda (i)
                                (if (>= i 0)
                                   (if (equal? (vector-ref nts i) nt)
                                      i
                                      (loop (- i 1)))
                                   #f))))
                  loop)
                  (- (vector-length nts) 1)))
            (lambda (_nt0 _nts0)
               ((letrec ((_loop0 (lambda (_i0)
                                  (if (= _i0 0) ;; NOT RENAMING >= -> =
                                     (if (equal? (vector-ref _nts0 _i0) _nt0)
                                        _i0
                                        (_loop0 (- _i0 1)))
                                     #f))))
                  _loop0)
                  (- (vector-length _nts0) 1)))))
      (define nb-configurations (<change>
            (lambda (grammar)
               ((letrec ((def-loop (lambda (defs nb-confs)
                                    (if (pair? defs)
                                       (let ((def (car defs)))
                                          ((letrec ((rule-loop (lambda (rules nb-confs)
                                                                (if (pair? rules)
                                                                   (let ((rule (car rules)))
                                                                      ((letrec ((loop (lambda (l nb-confs)
                                                                                       (if (pair? l)
                                                                                          (loop (cdr l) (+ nb-confs 1))
                                                                                          (rule-loop (cdr rules) (+ nb-confs 1))))))
                                                                         loop)
                                                                         rule
                                                                         nb-confs))
                                                                   (def-loop (cdr defs) nb-confs)))))
                                             rule-loop)
                                             (cdr def)
                                             nb-confs))
                                       nb-confs))))
                  def-loop)
                  grammar
                  0))
            (lambda (_grammar0)
               ((letrec ((_def-loop0 (lambda (_defs0 _nb-confs0)
                                      (if (not (pair? _defs0)) ;; NOT RENAMING, inserted not
                                         (let ((_def0 (car _defs0)))
                                            ((letrec ((_rule-loop0 (lambda (_rules0 _nb-confs1)
                                                                    (if (pair? _rules0)
                                                                       (let ((_rule0 (car _rules0)))
                                                                          ((letrec ((_loop0 (lambda (_l0 _nb-confs2)
                                                                                             (if (pair? _l0)
                                                                                                (_loop0 (cdr _l0) (+ _nb-confs2 1))
                                                                                                (_rule-loop0 (cdr _rules0) (+ _nb-confs2 1))))))
                                                                             _loop0)
                                                                             _rule0
                                                                             _nb-confs1))
                                                                       (_def-loop0 (cdr _defs0) _nb-confs1)))))
                                               _rule-loop0)
                                               (cdr _def0)
                                               _nb-confs0))
                                         _nb-confs0))))
                  _def-loop0)
                  _grammar0
                  0))))
      (let* ((nts (non-terminals grammar))
             (nb-nts (vector-length nts))
             (nb-confs (+ (nb-configurations grammar) nb-nts))
             (starters (make-vector nb-nts ()))
             (enders (make-vector nb-nts ()))
             (predictors (make-vector nb-nts ()))
             (steps (make-vector nb-confs #f))
             (names (make-vector nb-confs #f)))
         (define setup-tables (lambda (grammar nts starters enders predictors steps names)
               (define add-conf (lambda (conf nt nts class)
                     (<change>
                        (let ((i (ind nt nts)))
                           (vector-set! class i (cons conf (vector-ref class i))))
                        (let ((_i0 (ind nt nts)))
                           (vector-set! class _i0 (cons conf (vector-ref class _i0)))))))
               (let ((nb-nts (vector-length nts)))
                  ((<change>
                     (letrec ((nt-loop (lambda (i)
                                         (if (>= i 0)
                                            (begin
                                               (vector-set! steps i (- i nb-nts))
                                               (vector-set! names i (list (vector-ref nts i) 0))
                                               (vector-set! enders i (list i))
                                               (nt-loop (- i 1)))
                                            #f))))
                        nt-loop)
                     (letrec ((_nt-loop0 (lambda (_i0)
                                           (if (>= _i0 0) ;; NOT RENAMING
                                              (begin
                                                 (vector-set! steps _i0 (- _i0 nb-nts))
                                                 (vector-set! names _i0 (list (vector-ref nts _i0) 0))
                                                 (vector-set! enders _i0 (list _i0))
                                                 (_nt-loop0 (- _i0 1)))
                                              #f))))
                        _nt-loop0))
                     (- nb-nts 1))
                  ((letrec ((def-loop (<change>
                                       (lambda (defs conf)
                                          (if (pair? defs)
                                             (let* ((def (car defs))
                                                    (head (car def)))
                                                ((letrec ((rule-loop (lambda (rules conf rule-num)
                                                                      (if (pair? rules)
                                                                         (let ((rule (car rules)))
                                                                            (vector-set! names conf (list head rule-num))
                                                                            (add-conf conf head nts starters)
                                                                            ((letrec ((loop (lambda (l conf)
                                                                                             (if (pair? l)
                                                                                                (let ((nt (car l)))
                                                                                                   (vector-set! steps conf (ind nt nts))
                                                                                                   (add-conf conf nt nts predictors)
                                                                                                   (loop (cdr l) (+ conf 1)))
                                                                                                (begin
                                                                                                   (vector-set! steps conf (- (ind head nts) nb-nts))
                                                                                                   (add-conf conf head nts enders)
                                                                                                   (rule-loop (cdr rules) (+ conf 1) (+ rule-num 1)))))))
                                                                               loop)
                                                                               rule
                                                                               conf))
                                                                         (def-loop (cdr defs) conf)))))
                                                   rule-loop)
                                                   (cdr def)
                                                   conf
                                                   1))
                                             #f))
                                       (lambda (_defs0 _conf0)
                                          (if (pair? _defs0)
                                             (let* ((_def0 (car _defs0))
                                                    (_head0 (car _def0)))
                                                ((letrec ((_rule-loop0 (lambda (_rules0 _conf1 _rule-num0)
                                                                        (if (pair? _rules0)
                                                                           (let ((_rule0 (car _rules0)))
                                                                              (vector-set! names _conf1 (list _head0 _rule-num0))
                                                                              (add-conf _conf1 _head0 nts starters)
                                                                              ((letrec ((_loop0 (lambda (_l0 _conf2)
                                                                                                 (if (pair? _l0)
                                                                                                    (let ((_nt0 (car _l0)))
                                                                                                       (vector-set! steps _conf2 (ind _nt0 nts))
                                                                                                       (add-conf _conf2 _nt0 nts predictors)
                                                                                                       (_loop0 (cdr _l0) (+ _conf2 1)))
                                                                                                    (begin
                                                                                                       (vector-set! steps _conf2 (- (ind _head0 nts) nb-nts))
                                                                                                       (add-conf _conf2 _head0 nts enders)
                                                                                                       (_rule-loop0 (cdr _rules0) (+ _conf2 1) (+ _rule-num0 1)))))))
                                                                                 _loop0)
                                                                                 _rule0
                                                                                 _conf1))
                                                                           (def-loop (cdr _defs0) _conf1)))))
                                                   _rule-loop0)
                                                   (cdr _def0)
                                                   _conf0
                                                   1))
                                             #f)))))
                     def-loop)
                     grammar
                     (vector-length nts)))))
         (setup-tables grammar nts starters enders predictors steps names)
         (<change>
            (let ((parser-descr (vector lexer nts starters enders predictors steps names)))
               (lambda (input)
                  (define ind (lambda (nt nts)
                        ((letrec ((loop (lambda (i)
                                         (if (>= i 0)
                                            (if (equal? (vector-ref nts i) nt)
                                               i
                                               (loop (- i 1)))
                                            #f))))
                           loop)
                           (- (vector-length nts) 1))))
                  (define comp-tok (lambda (tok nts)
                        ((letrec ((loop (lambda (l1 l2)
                                         (if (pair? l1)
                                            (let ((i (ind (car l1) nts)))
                                               (if i
                                                  (loop (cdr l1) (cons i l2))
                                                  (loop (cdr l1) l2)))
                                            (cons (car tok) (reverse l2))))))
                           loop)
                           (cdr tok)
                           ())))
                  (define input->tokens (lambda (input lexer nts)
                        (list->vector (map (lambda (tok) (comp-tok tok nts)) (lexer input)))))
                  (define make-states (lambda (nb-toks nb-confs)
                        (let ((states (make-vector (+ nb-toks 1) #f)))
                           ((letrec ((loop (lambda (i)
                                            (if (>= i 0)
                                               (let ((v (make-vector (+ nb-confs 1) #f)))
                                                  (vector-set! v 0 -1)
                                                  (vector-set! states i v)
                                                  (loop (- i 1)))
                                               states))))
                              loop)
                              nb-toks))))
                  (define conf-set-get (lambda (state conf)
                        (vector-ref state (+ conf 1))))
                  (define conf-set-get* (lambda (state state-num conf)
                        (let ((conf-set (conf-set-get state conf)))
                           (if conf-set
                              conf-set
                              (let ((conf-set (make-vector (+ state-num 6) #f)))
                                 (vector-set! conf-set 1 -3)
                                 (vector-set! conf-set 2 -1)
                                 (vector-set! conf-set 3 -1)
                                 (vector-set! conf-set 4 -1)
                                 (vector-set! state (+ conf 1) conf-set)
                                 conf-set)))))
                  (define conf-set-merge-new! (lambda (conf-set)
                        (vector-set! conf-set (+ (vector-ref conf-set 1) 5) (vector-ref conf-set 4))
                        (vector-set! conf-set 1 (vector-ref conf-set 3))
                        (vector-set! conf-set 3 -1)
                        (vector-set! conf-set 4 -1)))
                  (define conf-set-head (lambda (conf-set)
                        (vector-ref conf-set 2)))
                  (define conf-set-next (lambda (conf-set i)
                        (vector-ref conf-set (+ i 5))))
                  (define conf-set-member? (lambda (state conf i)
                        (let ((conf-set (vector-ref state (+ conf 1))))
                           (if conf-set (conf-set-next conf-set i) #f))))
                  (define conf-set-adjoin (lambda (state conf-set conf i)
                        (let ((tail (vector-ref conf-set 3)))
                           (vector-set! conf-set (+ i 5) -1)
                           (vector-set! conf-set (+ tail 5) i)
                           (vector-set! conf-set 3 i)
                           (if (< tail 0)
                              (begin
                                 (vector-set! conf-set 0 (vector-ref state 0))
                                 (vector-set! state 0 conf))
                              #f))))
                  (define conf-set-adjoin* (lambda (states state-num l i)
                        (let ((state (vector-ref states state-num)))
                           ((letrec ((loop (lambda (l1)
                                            (if (pair? l1)
                                               (let* ((conf (car l1))
                                                      (conf-set (conf-set-get* state state-num conf)))
                                                  (if (not (conf-set-next conf-set i))
                                                     (begin
                                                        (conf-set-adjoin state conf-set conf i)
                                                        (loop (cdr l1)))
                                                     (loop (cdr l1))))
                                               #f))))
                              loop)
                              l))))
                  (define conf-set-adjoin** (lambda (states states* state-num conf i)
                        (let ((state (vector-ref states state-num)))
                           (if (conf-set-member? state conf i)
                              (let* ((state* (vector-ref states* state-num))
                                     (conf-set* (conf-set-get* state* state-num conf)))
                                 (if (not (conf-set-next conf-set* i))
                                    (conf-set-adjoin state* conf-set* conf i)
                                    #f)
                                 #t)
                              #f))))
                  (define conf-set-union (lambda (state conf-set conf other-set)
                        ((letrec ((loop (lambda (i)
                                         (if (>= i 0)
                                            (if (not (conf-set-next conf-set i))
                                               (begin
                                                  (conf-set-adjoin state conf-set conf i)
                                                  (loop (conf-set-next other-set i)))
                                               (loop (conf-set-next other-set i)))
                                            #f))))
                           loop)
                           (conf-set-head other-set))))
                  (define forw (lambda (states state-num starters enders predictors steps nts)
                        (define predict (lambda (state state-num conf-set conf nt starters enders)
                              ((letrec ((loop1 (lambda (l)
                                                (if (pair? l)
                                                   (let* ((starter (car l))
                                                          (starter-set (conf-set-get* state state-num starter)))
                                                      (if (not (conf-set-next starter-set state-num))
                                                         (begin
                                                            (conf-set-adjoin state starter-set starter state-num)
                                                            (loop1 (cdr l)))
                                                         (loop1 (cdr l))))
                                                   #f))))
                                 loop1)
                                 (vector-ref starters nt))
                              ((letrec ((loop2 (lambda (l)
                                                (if (pair? l)
                                                   (let ((ender (car l)))
                                                      (if (conf-set-member? state ender state-num)
                                                         (let* ((next (+ conf 1))
                                                                (next-set (conf-set-get* state state-num next)))
                                                            (conf-set-union state next-set next conf-set)
                                                            (loop2 (cdr l)))
                                                         (loop2 (cdr l))))
                                                   #f))))
                                 loop2)
                                 (vector-ref enders nt))))
                        (define reduce (lambda (states state state-num conf-set head preds)
                              ((letrec ((loop1 (lambda (l)
                                                (if (pair? l)
                                                   (let ((pred (car l)))
                                                      ((letrec ((loop2 (lambda (i)
                                                                        (if (>= i 0)
                                                                           (let ((pred-set (conf-set-get (vector-ref states i) pred)))
                                                                              (if pred-set
                                                                                 (let* ((next (+ pred 1))
                                                                                        (next-set (conf-set-get* state state-num next)))
                                                                                    (conf-set-union state next-set next pred-set))
                                                                                 #f)
                                                                              (loop2 (conf-set-next conf-set i)))
                                                                           (loop1 (cdr l))))))
                                                         loop2)
                                                         head))
                                                   #f))))
                                 loop1)
                                 preds)))
                        (let ((state (vector-ref states state-num))
                              (nb-nts (vector-length nts)))
                           ((letrec ((loop (lambda ()
                                            (let ((conf (vector-ref state 0)))
                                               (if (>= conf 0)
                                                  (let* ((step (vector-ref steps conf))
                                                         (conf-set (vector-ref state (+ conf 1)))
                                                         (head (vector-ref conf-set 4)))
                                                     (vector-set! state 0 (vector-ref conf-set 0))
                                                     (conf-set-merge-new! conf-set)
                                                     (if (>= step 0)
                                                        (predict state state-num conf-set conf step starters enders)
                                                        (let ((preds (vector-ref predictors (+ step nb-nts))))
                                                           (reduce states state state-num conf-set head preds)))
                                                     (loop))
                                                  #f)))))
                              loop)))))
                  (define forward (lambda (starters enders predictors steps nts toks)
                        (let* ((nb-toks (vector-length toks))
                               (nb-confs (vector-length steps))
                               (states (make-states nb-toks nb-confs))
                               (goal-starters (vector-ref starters 0)))
                           (conf-set-adjoin* states 0 goal-starters 0)
                           (forw states 0 starters enders predictors steps nts)
                           ((letrec ((loop (lambda (i)
                                            (if (< i nb-toks)
                                               (let ((tok-nts (cdr (vector-ref toks i))))
                                                  (conf-set-adjoin* states (+ i 1) tok-nts i)
                                                  (forw states (+ i 1) starters enders predictors steps nts)
                                                  (loop (+ i 1)))
                                               #f))))
                              loop)
                              0)
                           states)))
                  (define produce (lambda (conf i j enders steps toks states states* nb-nts)
                        (let ((prev (- conf 1)))
                           (if (if (>= conf nb-nts) (>= (vector-ref steps prev) 0) #f)
                              ((letrec ((loop1 (lambda (l)
                                                (if (pair? l)
                                                   (let* ((ender (car l))
                                                          (ender-set (conf-set-get (vector-ref states j) ender)))
                                                      (if ender-set
                                                         ((letrec ((loop2 (lambda (k)
                                                                           (if (>= k 0)
                                                                              (begin
                                                                                 (if (>= k i)
                                                                                    (if (conf-set-adjoin** states states* k prev i)
                                                                                       (conf-set-adjoin** states states* j ender k)
                                                                                       #f)
                                                                                    #f)
                                                                                 (loop2 (conf-set-next ender-set k)))
                                                                              (loop1 (cdr l))))))
                                                            loop2)
                                                            (conf-set-head ender-set))
                                                         (loop1 (cdr l))))
                                                   #f))))
                                 loop1)
                                 (vector-ref enders (vector-ref steps prev)))
                              #f))))
                  (define back (lambda (states states* state-num enders steps nb-nts toks)
                        (let ((state* (vector-ref states* state-num)))
                           ((letrec ((loop1 (lambda ()
                                             (let ((conf (vector-ref state* 0)))
                                                (if (>= conf 0)
                                                   (let* ((conf-set (vector-ref state* (+ conf 1)))
                                                          (head (vector-ref conf-set 4)))
                                                      (vector-set! state* 0 (vector-ref conf-set 0))
                                                      (conf-set-merge-new! conf-set)
                                                      ((letrec ((loop2 (lambda (i)
                                                                        (if (>= i 0)
                                                                           (begin
                                                                              (produce conf i state-num enders steps toks states states* nb-nts)
                                                                              (loop2 (conf-set-next conf-set i)))
                                                                           (loop1)))))
                                                         loop2)
                                                         head))
                                                   #f)))))
                              loop1)))))
                  (define backward (lambda (states enders steps nts toks)
                        (let* ((nb-toks (vector-length toks))
                               (nb-confs (vector-length steps))
                               (nb-nts (vector-length nts))
                               (states* (make-states nb-toks nb-confs))
                               (goal-enders (vector-ref enders 0)))
                           ((letrec ((loop1 (lambda (l)
                                             (if (pair? l)
                                                (let ((conf (car l)))
                                                   (conf-set-adjoin** states states* nb-toks conf 0)
                                                   (loop1 (cdr l)))
                                                #f))))
                              loop1)
                              goal-enders)
                           ((letrec ((loop2 (lambda (i)
                                             (if (>= i 0)
                                                (begin
                                                   (back states states* i enders steps nb-nts toks)
                                                   (loop2 (- i 1)))
                                                #f))))
                              loop2)
                              nb-toks)
                           states*)))
                  (define parsed? (lambda (nt i j nts enders states)
                        (let ((nt* (ind nt nts)))
                           (if nt*
                              (let ((nb-nts (vector-length nts)))
                                 ((letrec ((loop (lambda (l)
                                                  (if (pair? l)
                                                     (let ((conf (car l)))
                                                        (if (conf-set-member? (vector-ref states j) conf i)
                                                           #t
                                                           (loop (cdr l))))
                                                     #f))))
                                    loop)
                                    (vector-ref enders nt*)))
                              #f))))
                  (define deriv-trees (lambda (conf i j enders steps names toks states nb-nts)
                        (let ((name (vector-ref names conf)))
                           (if name
                              (if (< conf nb-nts)
                                 (list (list name (car (vector-ref toks i))))
                                 (list (list name)))
                              (let ((prev (- conf 1)))
                                 ((letrec ((loop1 (lambda (l1 l2)
                                                   (if (pair? l1)
                                                      (let* ((ender (car l1))
                                                             (ender-set (conf-set-get (vector-ref states j) ender)))
                                                         (if ender-set
                                                            ((letrec ((loop2 (lambda (k l2)
                                                                              (if (>= k 0)
                                                                                 (if (if (>= k i) (conf-set-member? (vector-ref states k) prev i) #f)
                                                                                    (let ((prev-trees (deriv-trees prev i k enders steps names toks states nb-nts))
                                                                                          (ender-trees (deriv-trees ender k j enders steps names toks states nb-nts)))
                                                                                       ((letrec ((loop3 (lambda (l3 l2)
                                                                                                         (if (pair? l3)
                                                                                                            (let ((ender-tree (list (car l3))))
                                                                                                               ((letrec ((loop4 (lambda (l4 l2)
                                                                                                                                 (if (pair? l4)
                                                                                                                                    (loop4 (cdr l4) (cons (append (car l4) ender-tree) l2))
                                                                                                                                    (loop3 (cdr l3) l2)))))
                                                                                                                  loop4)
                                                                                                                  prev-trees
                                                                                                                  l2))
                                                                                                            (loop2 (conf-set-next ender-set k) l2)))))
                                                                                          loop3)
                                                                                          ender-trees
                                                                                          l2))
                                                                                    (loop2 (conf-set-next ender-set k) l2))
                                                                                 (loop1 (cdr l1) l2)))))
                                                               loop2)
                                                               (conf-set-head ender-set)
                                                               l2)
                                                            (loop1 (cdr l1) l2)))
                                                      l2))))
                                    loop1)
                                    (vector-ref enders (vector-ref steps prev))
                                    ()))))))
                  (define deriv-trees* (lambda (nt i j nts enders steps names toks states)
                        (let ((nt* (ind nt nts)))
                           (if nt*
                              (let ((nb-nts (vector-length nts)))
                                 ((letrec ((loop (lambda (l trees)
                                                  (if (pair? l)
                                                     (let ((conf (car l)))
                                                        (if (conf-set-member? (vector-ref states j) conf i)
                                                           (loop (cdr l) (append (deriv-trees conf i j enders steps names toks states nb-nts) trees))
                                                           (loop (cdr l) trees)))
                                                     trees))))
                                    loop)
                                    (vector-ref enders nt*)
                                    ()))
                              #f))))
                  (define nb-deriv-trees (lambda (conf i j enders steps toks states nb-nts)
                        (let ((prev (- conf 1)))
                           (if (let ((__or_res (< conf nb-nts))) (if __or_res __or_res (< (vector-ref steps prev) 0)))
                              1
                              ((letrec ((loop1 (lambda (l n)
                                                (if (pair? l)
                                                   (let* ((ender (car l))
                                                          (ender-set (conf-set-get (vector-ref states j) ender)))
                                                      (if ender-set
                                                         ((letrec ((loop2 (lambda (k n)
                                                                           (if (>= k 0)
                                                                              (if (if (>= k i) (conf-set-member? (vector-ref states k) prev i) #f)
                                                                                 (let ((nb-prev-trees (nb-deriv-trees prev i k enders steps toks states nb-nts))
                                                                                       (nb-ender-trees (nb-deriv-trees ender k j enders steps toks states nb-nts)))
                                                                                    (loop2 (conf-set-next ender-set k) (+ n (* nb-prev-trees nb-ender-trees))))
                                                                                 (loop2 (conf-set-next ender-set k) n))
                                                                              (loop1 (cdr l) n)))))
                                                            loop2)
                                                            (conf-set-head ender-set)
                                                            n)
                                                         (loop1 (cdr l) n)))
                                                   n))))
                                 loop1)
                                 (vector-ref enders (vector-ref steps prev))
                                 0)))))
                  (define nb-deriv-trees* (lambda (nt i j nts enders steps toks states)
                        (let ((nt* (ind nt nts)))
                           (if nt*
                              (let ((nb-nts (vector-length nts)))
                                 ((letrec ((loop (lambda (l nb-trees)
                                                  (if (pair? l)
                                                     (let ((conf (car l)))
                                                        (if (conf-set-member? (vector-ref states j) conf i)
                                                           (loop (cdr l) (+ (nb-deriv-trees conf i j enders steps toks states nb-nts) nb-trees))
                                                           (loop (cdr l) nb-trees)))
                                                     nb-trees))))
                                    loop)
                                    (vector-ref enders nt*)
                                    0))
                              #f))))
                  (let* ((lexer (vector-ref parser-descr 0))
                         (nts (vector-ref parser-descr 1))
                         (starters (vector-ref parser-descr 2))
                         (enders (vector-ref parser-descr 3))
                         (predictors (vector-ref parser-descr 4))
                         (steps (vector-ref parser-descr 5))
                         (names (vector-ref parser-descr 6))
                         (toks (input->tokens input lexer nts)))
                     (vector
                        nts
                        starters
                        enders
                        predictors
                        steps
                        names
                        toks
                        (backward (forward starters enders predictors steps nts toks) enders steps nts toks)
                        parsed?
                        deriv-trees*
                        nb-deriv-trees*))))
            (let ((_parser-descr0 (vector lexer nts starters enders predictors steps names)))
               (lambda (_input0)
                  (define ind (lambda (_nt0 _nts0)
                        ((letrec ((_loop0 (lambda (_i0)
                                           (if (>= _i0 0)
                                              (if (equal? (vector-ref _nts0 _i0) _nt0)
                                                 _i0
                                                 (_loop0 (- _i0 1)))
                                              #f))))
                           _loop0)
                           (- (vector-length _nts0) 1))))
                  (define comp-tok (lambda (_tok0 _nts1)
                        ((letrec ((_loop1 (lambda (_l10 _l20)
                                           (if (pair? _l10)
                                              (let ((_i1 (ind (car _l10) _nts1)))
                                                 (if _i1
                                                    (_loop1 (cdr _l10) (cons _i1 _l20))
                                                    (_loop1 (cdr _l10) _l20)))
                                              (cons (car _tok0) (reverse _l20))))))
                           _loop1)
                           (cdr _tok0)
                           ())))
                  (define input->tokens (lambda (_input1 _lexer0 _nts2)
                        (list->vector (map (lambda (_tok1) (comp-tok _tok1 _nts2)) (_lexer0 _input1)))))
                  (define make-states (lambda (_nb-toks0 _nb-confs0)
                        (let ((_states0 (make-vector (+ _nb-toks0 1) #f)))
                           ((letrec ((_loop2 (lambda (_i2)
                                              (if (>= _i2 0)
                                                 (let ((_v0 (make-vector (+ _nb-confs0 1) #f)))
                                                    (vector-set! _v0 0 -1)
                                                    (vector-set! _states0 _i2 _v0)
                                                    (_loop2 (- _i2 1)))
                                                 _states0))))
                              _loop2)
                              _nb-toks0))))
                  (define conf-set-get (lambda (_state0 _conf0)
                        (vector-ref _state0 (+ _conf0 1))))
                  (define conf-set-get* (lambda (_state1 _state-num0 _conf1)
                        (let ((_conf-set0 (conf-set-get _state1 _conf1)))
                           (if _conf-set0
                              _conf-set0
                              (let ((_conf-set1 (make-vector (+ _state-num0 6) #f)))
                                 (vector-set! _conf-set1 1 -3)
                                 (vector-set! _conf-set1 2 -1)
                                 (vector-set! _conf-set1 3 -1)
                                 (vector-set! _conf-set1 4 -1)
                                 (vector-set! _state1 (+ _conf1 1) _conf-set1)
                                 _conf-set1)))))
                  (define conf-set-merge-new! (lambda (_conf-set2)
                        (vector-set! _conf-set2 (+ (vector-ref _conf-set2 1) 5) (vector-ref _conf-set2 4))
                        (vector-set! _conf-set2 1 (vector-ref _conf-set2 3))
                        (vector-set! _conf-set2 3 -1)
                        (vector-set! _conf-set2 4 -1)))
                  (define conf-set-head (lambda (_conf-set3)
                        (vector-ref _conf-set3 2)))
                  (define conf-set-next (lambda (_conf-set4 _i3)
                        (vector-ref _conf-set4 (+ _i3 5))))
                  (define conf-set-member? (lambda (_state2 _conf2 _i4)
                        (let ((_conf-set5 (vector-ref _state2 (+ _conf2 1))))
                           (if _conf-set5 (conf-set-next _conf-set5 _i4) #f))))
                  (define conf-set-adjoin (lambda (_state3 _conf-set6 _conf3 _i5)
                        (let ((_tail0 (vector-ref _conf-set6 3)))
                           (vector-set! _conf-set6 (+ _i5 5) -1)
                           (vector-set! _conf-set6 (+ _tail0 5) _i5)
                           (vector-set! _conf-set6 3 _i5)
                           (if (< _tail0 0)
                              (begin
                                 (vector-set! _conf-set6 0 (vector-ref _state3 0))
                                 (vector-set! _state3 0 _conf3))
                              #f))))
                  (define conf-set-adjoin* (lambda (_states1 _state-num1 _l0 _i6)
                        (let ((_state4 (vector-ref _states1 _state-num1)))
                           ((letrec ((_loop3 (lambda (_l11)
                                              (if (pair? _l11)
                                                 (let* ((_conf4 (car _l11))
                                                        (_conf-set7 (conf-set-get* _state4 _state-num1 _conf4)))
                                                    (if (not (conf-set-next _conf-set7 _i6))
                                                       (begin
                                                          (conf-set-adjoin _state4 _conf-set7 _conf4 _i6)
                                                          (_loop3 (cdr _l11)))
                                                       (_loop3 (cdr _l11))))
                                                 #f))))
                              _loop3)
                              _l0))))
                  (define conf-set-adjoin** (lambda (_states2 _states*0 _state-num2 _conf5 _i7)
                        (let ((_state5 (vector-ref _states2 _state-num2)))
                           (if (conf-set-member? _state5 _conf5 _i7)
                              (let* ((_state*0 (vector-ref _states*0 _state-num2))
                                     (_conf-set*0 (conf-set-get* _state*0 _state-num2 _conf5)))
                                 (if (not (conf-set-next _conf-set*0 _i7))
                                    (conf-set-adjoin _state*0 _conf-set*0 _conf5 _i7)
                                    #f)
                                 #t)
                              #f))))
                  (define conf-set-union (lambda (_state6 _conf-set8 _conf6 _other-set0)
                        ((letrec ((_loop4 (lambda (_i8)
                                           (if (>= _i8 0)
                                              (if (not (conf-set-next _conf-set8 _i8))
                                                 (begin
                                                    (conf-set-adjoin _state6 _conf-set8 _conf6 _i8)
                                                    (_loop4 (conf-set-next _other-set0 _i8)))
                                                 (_loop4 (conf-set-next _other-set0 _i8)))
                                              #f))))
                           _loop4)
                           (conf-set-head _other-set0))))
                  (define forw (lambda (_states3 _state-num3 _starters0 _enders0 _predictors0 _steps0 _nts3)
                        (define predict (lambda (_state7 _state-num4 _conf-set9 _conf7 _nt1 _starters1 _enders1)
                              ((letrec ((_loop10 (lambda (_l1)
                                                  (if (pair? _l1)
                                                     (let* ((_starter0 (car _l1))
                                                            (_starter-set0 (conf-set-get* _state7 _state-num4 _starter0)))
                                                        (if (not (conf-set-next _starter-set0 _state-num4))
                                                           (begin
                                                              (conf-set-adjoin _state7 _starter-set0 _starter0 _state-num4)
                                                              (_loop10 (cdr _l1)))
                                                           (_loop10 (cdr _l1))))
                                                     #f))))
                                 _loop10)
                                 (vector-ref _starters1 _nt1))
                              ((letrec ((_loop20 (lambda (_l2)
                                                  (if (pair? _l2)
                                                     (let ((_ender0 (car _l2)))
                                                        (if (conf-set-member? _state7 _ender0 _state-num4)
                                                           (let* ((_next0 (+ _conf7 1))
                                                                  (_next-set0 (conf-set-get* _state7 _state-num4 _next0)))
                                                              (conf-set-union _state7 _next-set0 _next0 _conf-set9)
                                                              (_loop20 (cdr _l2)))
                                                           (_loop20 (cdr _l2))))
                                                     #f))))
                                 _loop20)
                                 (vector-ref _enders1 _nt1))))
                        (define reduce (lambda (_states4 _state8 _state-num5 _conf-set10 _head0 _preds0)
                              ((letrec ((_loop11 (lambda (_l3)
                                                  (if (pair? _l3)
                                                     (let ((_pred0 (car _l3)))
                                                        ((letrec ((_loop21 (lambda (_i9)
                                                                            (if (>= _i9 0)
                                                                               (let ((_pred-set0 (conf-set-get (vector-ref _states4 _i9) _pred0)))
                                                                                  (if _pred-set0
                                                                                     (let* ((_next1 (+ _pred0 1))
                                                                                            (_next-set1 (conf-set-get* _state8 _state-num5 _next1)))
                                                                                        (conf-set-union _state8 _next-set1 _next1 _pred-set0))
                                                                                     #f)
                                                                                  (_loop21 (conf-set-next _conf-set10 _i9)))
                                                                               (_loop11 (cdr _l3))))))
                                                           _loop21)
                                                           _head0))
                                                     #f))))
                                 _loop11)
                                 _preds0)))
                        (let ((_state9 (vector-ref _states3 _state-num3))
                              (_nb-nts0 (vector-length _nts3)))
                           ((letrec ((_loop5 (lambda ()
                                              (let ((_conf8 (vector-ref _state9 0)))
                                                 (if (>= _conf8 0)
                                                    (let* ((_step0 (vector-ref _steps0 _conf8))
                                                           (_conf-set11 (vector-ref _state9 (+ _conf8 1)))
                                                           (_head1 (vector-ref _conf-set11 4)))
                                                       (vector-set! _state9 0 (vector-ref _conf-set11 0))
                                                       (conf-set-merge-new! _conf-set11)
                                                       (if (>= _step0 0)
                                                          (predict _state9 _state-num3 _conf-set11 _conf8 _step0 _starters0 _enders0)
                                                          (let ((_preds1 (vector-ref _predictors0 (+ _step0 _nb-nts0))))
                                                             (reduce _states3 _state9 _state-num3 _conf-set11 _head1 _preds1)))
                                                       (_loop5))
                                                    #f)))))
                              _loop5)))))
                  (define forward (lambda (_starters2 _enders2 _predictors1 _steps1 _nts4 _toks0)
                        (let* ((_nb-toks1 (vector-length _toks0))
                               (_nb-confs1 (vector-length _steps1))
                               (_states5 (make-states _nb-toks1 _nb-confs1))
                               (_goal-starters0 (vector-ref _starters2 0)))
                           (conf-set-adjoin* _states5 0 _goal-starters0 0)
                           (forw _states5 0 _starters2 _enders2 _predictors1 _steps1 _nts4)
                           ((letrec ((_loop6 (lambda (_i10)
                                              (if (< _i10 _nb-toks1)
                                                 (let ((_tok-nts0 (cdr (vector-ref _toks0 _i10))))
                                                    (conf-set-adjoin* _states5 (+ _i10 1) _tok-nts0 _i10)
                                                    (forw _states5 (+ _i10 1) _starters2 _enders2 _predictors1 _steps1 _nts4)
                                                    (_loop6 (+ _i10 1)))
                                                 #f))))
                              _loop6)
                              0)
                           _states5)))
                  (define produce (lambda (_conf9 _i11 _j0 _enders3 _steps2 _toks1 _states6 _states*1 _nb-nts1)
                        (let ((_prev0 (- _conf9 1)))
                           (if (if (>= _conf9 _nb-nts1) (>= (vector-ref _steps2 _prev0) 0) #f)
                              ((letrec ((_loop12 (lambda (_l4)
                                                  (if (pair? _l4)
                                                     (let* ((_ender1 (car _l4))
                                                            (_ender-set0 (conf-set-get (vector-ref _states6 _j0) _ender1)))
                                                        (if _ender-set0
                                                           ((letrec ((_loop22 (lambda (_k0)
                                                                               (if (>= _k0 0)
                                                                                  (begin
                                                                                     (if (>= _k0 _i11)
                                                                                        (if (conf-set-adjoin** _states6 _states*1 _k0 _prev0 _i11)
                                                                                           (conf-set-adjoin** _states6 _states*1 _j0 _ender1 _k0)
                                                                                           #f)
                                                                                        #f)
                                                                                     (_loop22 (conf-set-next _ender-set0 _k0)))
                                                                                  (_loop12 (cdr _l4))))))
                                                              _loop22)
                                                              (conf-set-head _ender-set0))
                                                           (_loop12 (cdr _l4))))
                                                     #f))))
                                 _loop12)
                                 (vector-ref _enders3 (vector-ref _steps2 _prev0)))
                              #f))))
                  (define back (lambda (_states7 _states*2 _state-num6 _enders4 _steps3 _nb-nts2 _toks2)
                        (let ((_state*1 (vector-ref _states*2 _state-num6)))
                           ((letrec ((_loop13 (lambda ()
                                               (let ((_conf10 (vector-ref _state*1 0)))
                                                  (if (>= _conf10 0)
                                                     (let* ((_conf-set12 (vector-ref _state*1 (+ _conf10 1)))
                                                            (_head2 (vector-ref _conf-set12 4)))
                                                        (vector-set! _state*1 0 (vector-ref _conf-set12 0))
                                                        (conf-set-merge-new! _conf-set12)
                                                        ((letrec ((_loop23 (lambda (_i12)
                                                                            (if (>= _i12 0)
                                                                               (begin
                                                                                  (produce _conf10 _i12 _state-num6 _enders4 _steps3 _toks2 _states7 _states*2 _nb-nts2)
                                                                                  (_loop23 (conf-set-next _conf-set12 _i12)))
                                                                               (_loop13)))))
                                                           _loop23)
                                                           _head2))
                                                     #f)))))
                              _loop13)))))
                  (define backward (lambda (_states8 _enders5 _steps4 _nts5 _toks3)
                        (let* ((_nb-toks2 (vector-length _toks3))
                               (_nb-confs2 (vector-length _steps4))
                               (_nb-nts3 (vector-length _nts5))
                               (_states*3 (make-states _nb-toks2 _nb-confs2))
                               (_goal-enders0 (vector-ref _enders5 0)))
                           ((letrec ((_loop14 (lambda (_l5)
                                               (if (pair? _l5)
                                                  (let ((_conf11 (car _l5)))
                                                     (conf-set-adjoin** _states8 _states*3 _nb-toks2 _conf11 0)
                                                     (_loop14 (cdr _l5)))
                                                  #f))))
                              _loop14)
                              _goal-enders0)
                           ((letrec ((_loop24 (lambda (_i13)
                                               (if (>= _i13 0)
                                                  (begin
                                                     (back _states8 _states*3 _i13 _enders5 _steps4 _nb-nts3 _toks3)
                                                     (_loop24 (- _i13 1)))
                                                  #f))))
                              _loop24)
                              _nb-toks2)
                           _states*3)))
                  (define parsed? (lambda (_nt2 _i14 _j1 _nts6 _enders6 _states9)
                        (let ((_nt*0 (ind _nt2 _nts6)))
                           (if _nt*0
                              (let ((_nb-nts4 (vector-length _nts6)))
                                 ((letrec ((_loop7 (lambda (_l6)
                                                    (if (pair? _l6)
                                                       (let ((_conf12 (car _l6)))
                                                          (if (conf-set-member? (vector-ref _states9 _j1) _conf12 _i14)
                                                             #t
                                                             (_loop7 (cdr _l6))))
                                                       #f))))
                                    _loop7)
                                    (vector-ref _enders6 _nt*0)))
                              #f))))
                  (define deriv-trees (lambda (_conf13 _i15 _j2 _enders7 _steps5 _names0 _toks4 _states10 _nb-nts5)
                        (let ((_name0 (vector-ref _names0 _conf13)))
                           (if _name0
                              (if (< _conf13 _nb-nts5)
                                 (list (list _name0 (car (vector-ref _toks4 _i15))))
                                 (list (list _name0)))
                              (let ((_prev1 (- _conf13 1)))
                                 ((letrec ((_loop15 (lambda (_l12 _l21)
                                                     (if (pair? _l12)
                                                        (let* ((_ender2 (car _l12))
                                                               (_ender-set1 (conf-set-get (vector-ref _states10 _j2) _ender2)))
                                                           (if _ender-set1
                                                              ((letrec ((_loop25 (lambda (_k1 _l22)
                                                                                  (if (>= _k1 0)
                                                                                     (if (if (>= _k1 _i15) (conf-set-member? (vector-ref _states10 _k1) _prev1 _i15) #f)
                                                                                        (let ((_prev-trees0 (deriv-trees _prev1 _i15 _k1 _enders7 _steps5 _names0 _toks4 _states10 _nb-nts5))
                                                                                              (_ender-trees0 (deriv-trees _ender2 _k1 _j2 _enders7 _steps5 _names0 _toks4 _states10 _nb-nts5)))
                                                                                           ((letrec ((_loop30 (lambda (_l30 _l23)
                                                                                                               (if (pair? _l30)
                                                                                                                  (let ((_ender-tree0 (list (car _l30))))
                                                                                                                     ((letrec ((_loop40 (lambda (_l40 _l24)
                                                                                                                                         (if (pair? _l40)
                                                                                                                                            (_loop40 (cdr _l40) (cons (append (car _l40) _ender-tree0) _l24))
                                                                                                                                            (_loop30 (cdr _l30) _l24)))))
                                                                                                                        _loop40)
                                                                                                                        _prev-trees0
                                                                                                                        _l23))
                                                                                                                  (_loop25 (conf-set-next _ender-set1 _k1) _l23)))))
                                                                                              _loop30)
                                                                                              _ender-trees0
                                                                                              _l22))
                                                                                        (_loop25 (conf-set-next _ender-set1 _k1) _l22))
                                                                                     (_loop15 (cdr _l12) _l22)))))
                                                                 _loop25)
                                                                 (conf-set-head _ender-set1)
                                                                 _l21)
                                                              (_loop15 (cdr _l12) _l21)))
                                                        _l21))))
                                    _loop15)
                                    (vector-ref _enders7 (vector-ref _steps5 _prev1))
                                    ()))))))
                  (define deriv-trees* (lambda (_nt3 _i16 _j3 _nts7 _enders8 _steps6 _names1 _toks5 _states11)
                        (let ((_nt*1 (ind _nt3 _nts7)))
                           (if _nt*1
                              (let ((_nb-nts6 (vector-length _nts7)))
                                 ((letrec ((_loop8 (lambda (_l7 _trees0)
                                                    (if (pair? _l7)
                                                       (let ((_conf14 (car _l7)))
                                                          (if (conf-set-member? (vector-ref _states11 _j3) _conf14 _i16)
                                                             (_loop8
                                                                (cdr _l7)
                                                                (append (deriv-trees _conf14 _i16 _j3 _enders8 _steps6 _names1 _toks5 _states11 _nb-nts6) _trees0))
                                                             (_loop8 (cdr _l7) _trees0)))
                                                       _trees0))))
                                    _loop8)
                                    (vector-ref _enders8 _nt*1)
                                    ()))
                              #f))))
                  (define nb-deriv-trees (lambda (_conf15 _i17 _j4 _enders9 _steps7 _toks6 _states12 _nb-nts7)
                        (let ((_prev2 (- _conf15 1)))
                           (if (let ((___or_res0 (< _conf15 _nb-nts7))) (if ___or_res0 ___or_res0 (< (vector-ref _steps7 _prev2) 0)))
                              1
                              ((letrec ((_loop16 (lambda (_l8 _n0)
                                                  (if (pair? _l8)
                                                     (let* ((_ender3 (car _l8))
                                                            (_ender-set2 (conf-set-get (vector-ref _states12 _j4) _ender3)))
                                                        (if _ender-set2
                                                           ((letrec ((_loop26 (lambda (_k2 _n1)
                                                                               (if (>= _k2 0)
                                                                                  (if (if (>= _k2 _i17) (conf-set-member? (vector-ref _states12 _k2) _prev2 _i17) #f)
                                                                                     (let ((_nb-prev-trees0 (nb-deriv-trees _prev2 _i17 _k2 _enders9 _steps7 _toks6 _states12 _nb-nts7))
                                                                                           (_nb-ender-trees0 (nb-deriv-trees _ender3 _k2 _j4 _enders9 _steps7 _toks6 _states12 _nb-nts7)))
                                                                                        (_loop26 (conf-set-next _ender-set2 _k2) (+ _n1 (* _nb-prev-trees0 _nb-ender-trees0))))
                                                                                     (_loop26 (conf-set-next _ender-set2 _k2) _n1))
                                                                                  (_loop16 (cdr _l8) _n1)))))
                                                              _loop26)
                                                              (conf-set-head _ender-set2)
                                                              _n0)
                                                           (_loop16 (cdr _l8) _n0)))
                                                     _n0))))
                                 _loop16)
                                 (vector-ref _enders9 (vector-ref _steps7 _prev2))
                                 0)))))
                  (define nb-deriv-trees* (lambda (_nt4 _i18 _j5 _nts8 _enders10 _steps8 _toks7 _states13)
                        (let ((_nt*2 (ind _nt4 _nts8)))
                           (if _nt*2
                              (let ((_nb-nts8 (vector-length _nts8)))
                                 ((letrec ((_loop9 (lambda (_l9 _nb-trees0)
                                                    (if (pair? _l9)
                                                       (let ((_conf16 (car _l9)))
                                                          (if (conf-set-member? (vector-ref _states13 _j5) _conf16 _i18)
                                                             (_loop9
                                                                (cdr _l9)
                                                                (+ (nb-deriv-trees _conf16 _i18 _j5 _enders10 _steps8 _toks7 _states13 _nb-nts8) _nb-trees0))
                                                             (_loop9 (cdr _l9) _nb-trees0)))
                                                       _nb-trees0))))
                                    _loop9)
                                    (vector-ref _enders10 _nt*2)
                                    0))
                              #f))))
                  (let* ((_lexer1 (vector-ref _parser-descr0 0))
                         (_nts9 (vector-ref _parser-descr0 1))
                         (_starters3 (vector-ref _parser-descr0 2))
                         (_enders11 (vector-ref _parser-descr0 3))
                         (_predictors2 (vector-ref _parser-descr0 4))
                         (_steps9 (vector-ref _parser-descr0 5))
                         (_names2 (vector-ref _parser-descr0 6))
                         (_toks8 (input->tokens _input0 _lexer1 _nts9)))
                     (vector
                        _nts9
                        _starters3
                        _enders11
                        _predictors2
                        _steps9
                        _names2
                        _toks8
                        (backward
                           (forward _starters3 _enders11 _predictors2 _steps9 _nts9 _toks8)
                           _enders11
                           _steps9
                           _nts9
                           _toks8)
                        parsed?
                        deriv-trees*
                        nb-deriv-trees*))))))))
 
(define parse->parsed? (lambda (parse nt i j)
      (let* ((nts (vector-ref parse 0))
             (enders (vector-ref parse 2))
             (states (vector-ref parse 7))
             (parsed? (vector-ref parse 8)))
         (parsed? nt i j nts enders states))))
 
(define parse->trees (<change>
      (lambda (parse nt i j)
         (let* ((nts (vector-ref parse 0))
                (enders (vector-ref parse 2))
                (steps (vector-ref parse 4))
                (names (vector-ref parse 5))
                (toks (vector-ref parse 6))
                (states (vector-ref parse 7))
                (deriv-trees* (vector-ref parse 9)))
            (deriv-trees* nt i j nts enders steps names toks states)))
      (lambda (_parse0 _nt0 _i0 _j0)
         (let* ((_nts0 (vector-ref _parse0 0))
                (_enders0 (vector-ref _parse0 2))
                (_steps0 (vector-ref _parse0 4))
                (_names0 (vector-ref _parse0 5))
                (_toks0 (vector-ref _parse0 6))
                (_states0 (vector-ref _parse0 7))
                (_deriv-trees*0 (vector-ref _parse0 9)))
            (_deriv-trees*0 _nt0 _i0 _j0 _nts0 _enders0 _steps0 _names0 _toks0 _states0)))))
 
(define parse->nb-trees (<change>
      (lambda (parse nt i j)
         (let* ((nts (vector-ref parse 0))
                (enders (vector-ref parse 2))
                (steps (vector-ref parse 4))
                (toks (vector-ref parse 6))
                (states (vector-ref parse 7))
                (nb-deriv-trees* (vector-ref parse 10)))
            (nb-deriv-trees* nt i j nts enders steps toks states)))
      (lambda (_parse0 _nt0 _i0 _j0)
         (let* ((_nts0 (vector-ref _parse0 0))
                (_enders0 (vector-ref _parse0 2))
                (_steps0 (vector-ref _parse0 4))
                (_toks0 (vector-ref _parse0 6))
                (_states0 (vector-ref _parse0 7))
                (_nb-deriv-trees*0 (vector-ref _parse0 10)))
            (_nb-deriv-trees*0 _nt0 _i0 _j0 _nts0 _enders0 _steps0 _toks0 _states0)))))
 
(define test (lambda ()
      (<change>
         (let ((p (make-parser
                    (__toplevel_cons
                       (__toplevel_cons
                          's
                          (__toplevel_cons
                             (__toplevel_cons 'a ())
                             (__toplevel_cons (__toplevel_cons 's (__toplevel_cons 's ())) ())))
                       ())
                    (lambda (l)
                       (map (lambda (x) (list x x)) l)))))
            (let ((x (p
                       (__toplevel_cons
                          'a
                          (__toplevel_cons
                             'a
                             (__toplevel_cons
                                'a
                                (__toplevel_cons
                                   'a
                                   (__toplevel_cons
                                      'a
                                      (__toplevel_cons 'a (__toplevel_cons 'a (__toplevel_cons 'a (__toplevel_cons 'a ()))))))))))))
               (length (parse->trees x 's 0 9))))
         (let ((_p0 (make-parser
                      (__toplevel_cons
                         (__toplevel_cons
                            's
                            (__toplevel_cons
                               (__toplevel_cons 'a ())
                               (__toplevel_cons (__toplevel_cons 's (__toplevel_cons 's ())) ())))
                         ())
                      (lambda (_l0)
                         (map (lambda (_x0) (list _x0 _x0)) _l0)))))
            (let ((_x1 (_p0
                         (__toplevel_cons
                            'a
                            (__toplevel_cons
                               'a
                               (__toplevel_cons
                                  'a
                                  (__toplevel_cons
                                     'a
                                     (__toplevel_cons
                                        'a
                                        (__toplevel_cons 'a (__toplevel_cons 'a (__toplevel_cons 'a (__toplevel_cons 'a ()))))))))))))
               (length (parse->trees _x1 's 0 9)))))))
 
(equal? (test) 1430)
 
