package maf.modular.incremental

//import maf.cli.runnables
import maf.aam.scheme.SchemeStoreAllocateReturn
import maf.core.*
import maf.language.scheme.interpreter.BaseSchemeInterpreter
import maf.language.scheme.interpreter.ConcreteValues.AddrInfo.VarAddr
import maf.language.scheme.interpreter.ConcreteValues.Value.Clo
import maf.language.scheme.interpreter.ConcreteValues.{Addr, AddrInfo}
import maf.language.scheme.lattices.{ModularSchemeLattice, SchemeOp}
import maf.language.scheme.*
import maf.lattice.interfaces.*
import maf.modular.AddrDependency
import maf.modular.incremental.scheme.lattice.IncrementalSchemeTypeDomain.modularLattice.incrementalSchemeLattice
import maf.modular.incremental.scheme.lattice.{IncrementalLattice, IncrementalModularSchemeLattice, IncrementalSchemeLattice, IncrementalSchemeTypeDomain}
import maf.modular.scheme.modf.{NoContext, SchemeModFComponent}
import maf.modular.scheme.{ModularSchemeLatticeWrapper, PrmAddr, SchemeAddr}


class IncrementalUpdateDatastructures {

  type VarAddr = maf.modular.scheme.VarAddr[_]
  type RetAddr = maf.modular.ReturnAddr[SchemeModFComponent]
  type PtrAddr = maf.modular.scheme.PtrAddr[_]
  type PrmAddr = maf.modular.scheme.PrmAddr
  type Value = maf.modular.incremental.scheme.lattice.IncrementalSchemeTypeDomain.modularLattice.Value

  var changedVars: Map[maf.core.Identifier, maf.core.Identifier] = Map()
  var changedExpressions: Map[maf.core.Expression, maf.core.Expression] = Map()
  var allExpressionsInChange: Map[maf.core.Expression, maf.core.Expression] = Map()

  // Call this function when you want to update all the datastructures of an analysis
  // Arguments are an analysis and the expression that is being analysed
  def changeDataStructures(a: IncrementalModAnalysis[SchemeExp], exp: SchemeExp): Boolean =
    val changed = SchemeChangePatterns.checkForRenamingParameter(exp) // get all renamings
    val changedVarsSwapped = changed.flatMap(e => e._2).toMap
    changedVars = changedVarsSwapped.map(_.swap).toMap // Get all renamed vars
    changedExpressions = changed.map(e => e._1).toMap // Get all expressions that have been changed

    // get all expressions that exist within an old expression and in a new expression and zip them together to know what has changed to what
    val allOldExps = changedExpressions.flatMap(e => findAllSubExps(e._1))
    val allNewExps = changedExpressions.flatMap(e => findAllSubExps(e._2))
    allExpressionsInChange = allOldExps.zip(allNewExps).toMap

    a match
      case analysis: IncrementalGlobalStore[SchemeExp] => // Update the store
        updateStore(analysis)
      case _ =>
    updateDependencies(a) // Update the dependencies
    true

  // Find all the subexpressions of an expression, and their subexpressions.
  // Something like (lambda (a) (+ a 1)) will become List((lambda (a) (+ a 1)), (+ a 1), +, a, 1)
  private def findAllSubExps(expr: Expression): List[Expression] =
    if expr.subexpressions.isEmpty && expr.height == 1 then
      List(expr)
    else if  expr.subexpressions.isEmpty then
      List()
    else List(expr).appendedAll(expr.subexpressions.flatMap(e => findAllSubExps(e)))

  // Update the store in case there is one
  // There are three types of keys that can contain changes: Variable addresses, Return addresses, and Pointer Addresses. Primitive address can not change
  // In each case, we first get a new value making use of getNewValues, as it has nothing to do with the keys
  // Then we call insertInStore with the analysis, the (old) key, the new key (generated by getNew...Addr), and the old and new value
  // insertInStore will handle cases where oldKey == newKey and/or oldValue == newValue
  def updateStore(a: IncrementalGlobalStore[SchemeExp]): Unit =
    a.store.foreach((oldKey, oldValue) =>
      val newValue = getNewValues(a, oldValue)
      oldKey match
        case key: VarAddr =>
          insertInStore(a, key, getNewVarAddr(key), oldValue, newValue)
        case key: RetAddr =>
          insertInStore(a, key, getNewRetAddr(key), oldValue, newValue)
        case key: PtrAddr =>
          insertInStore(a, key, getNewPointerAddr(key), oldValue, newValue)
        case _ =>
    )

  // Much like with the store, we first get a new value. However, in this case the value is a set of SchemeModFComponent, so we use getNewComponent on each element in the set
  // The address dependency can once again be 4 different addresses, but unlike the store, now the value of a dependency of PrmAddr can change (but the PrmAddr itself does not)
  // For each, we call insertInDeps with the analysis, the address depencency, the new address dependency, the old and new value
  // We reuse functions such as getNewVarAddr to get the new addr dependency
  def updateDependencies(a: IncrementalModAnalysis[SchemeExp]): Unit =
    a.deps.foreach((oldKey, oldValue) =>
      // Get a new set of values making use of getNewComponent
      val newValue = oldValue.map(e => e match
        case comp: SchemeModFComponent => getNewComponent(comp))
      (oldKey, newValue) match
        case (addrDep: AddrDependency, newValue: Set[a.Component]) =>
          addrDep.addr match
            case k: VarAddr =>
              insertInDeps(a, addrDep, addrDep.copy(addr = getNewVarAddr(k)), oldValue, newValue)
            case k: RetAddr =>
              insertInDeps(a, addrDep, addrDep.copy(addr = getNewRetAddr(k)), oldValue, newValue)
            case k: PtrAddr =>
              insertInDeps(a, addrDep, addrDep.copy(addr = getNewPointerAddr(k)), oldValue, newValue)
            case k: PrmAddr =>
              insertInDeps(a, addrDep, addrDep, oldValue, newValue)
      )

  // Insert something in the store:
  //  if the old and new key are the same, but the value has changed
  //  or if there is a new key (in this case: remove the old key)
  def insertInStore(a: IncrementalGlobalStore[SchemeExp], oldKey: Address, newKey: Address, oldValue: a.Value, newValue: a.Value): Unit =
    if newKey.equals(oldKey) then
      if !newValue.equals(oldValue) then
        a.store = a.store + (oldKey -> newValue)
    else
      a.store = a.store - oldKey
      a.store = a.store + (newKey -> newValue)

  // Insert something in the dependencies:
  //  if the old and new key are the same, but the value has changed
  //  or if there is a new key (in this case: remove the old key)
  def insertInDeps(a: IncrementalModAnalysis[SchemeExp], oldKey: maf.modular.Dependency, newKey: maf.modular.Dependency, oldValue: Set[a.Component], newValue: Set[a.Component]): Unit =
    if newKey.equals(oldKey) then
      if !newValue.equals(oldValue) then
        a.deps = a.deps + (oldKey -> newValue)
    else
      a.deps = a.deps - oldKey
      a.deps = a.deps + (newKey -> newValue)

  // A variable address can only change if the variable exists somewhere in the changed expression
  // In this case, get what the variable has changed into and use that to create the new address
  // Otherwise, just return the old address
  def getNewVarAddr(addr: VarAddr): VarAddr =
    if changedVars contains addr.id then
      val newIdn = changedVars.getOrElse(addr.id, addr.id)
      val newAddr = addr.copy(id = newIdn, ctx = addr.ctx)
      newAddr
    else addr

  // Together with the idn of the return address that can change, it contains a component that might need to change
  // First, we look if the key's component is a function call. If it is, we want to find if the lambda of the component exists within a changed expression
  // If it is indeed a lambda that needs changing, allExpressionsInChange.get(lam) will return Some(lambda), otherwise it will return None.
  // A new component is created making use of getNewComponent
  // If the lambda does not change, we just return the old address
  // The call might also be main, we just return the address
  def getNewRetAddr(addr: RetAddr): RetAddr =
    addr.cmp match
      case SchemeModFComponent.Main =>
        addr
      case SchemeModFComponent.Call((lam: SchemeLambdaExp, env: BasicEnvironment[_]), ctx: _) =>
        val changeToLambda = allExpressionsInChange.get(lam)
        changeToLambda match
          case Some(lambda: SchemeLambdaExp) =>
            val newCmp = getNewComponent(SchemeModFComponent.Call((lam, env), ctx))
            val newIdn = lambda.subexpressions.last.idn
            val newAddr = maf.modular.ReturnAddr[SchemeModFComponent](idn = newIdn, cmp = newCmp)
            newAddr
          case _ =>
            addr

  // Get a new component. First look if it is a Main call or a function call. In case of main, just return the old component
  // In the case of a function call, only change the component if it exists within a changed expression (otherwise return the old component)
  // Also create a new environment making use of createNewEnvironment
  def getNewComponent(comp: SchemeModFComponent): SchemeModFComponent =
    comp match
      case SchemeModFComponent.Main =>
        comp
      case SchemeModFComponent.Call((lam: SchemeLambdaExp, env: BasicEnvironment[_]), ctx: _) =>
        val changeToLambda = allExpressionsInChange.get(lam)
        changeToLambda match
          case Some(lambda: SchemeLambdaExp) =>
            var newEnv = createNewEnvironment(env)
            val newCmp = SchemeModFComponent.Call(clo = (lambda, new BasicEnvironment[Address](newEnv)), ctx = ctx)
            newCmp
          case None => comp


  // See if the expression is an expression that exists within a change expression. If not, nothing needs to happen. If so, it now becomes the expression of the new version
  def getNewPointerAddr(addr: PtrAddr): PtrAddr =
    val changeToExp = allExpressionsInChange.get(addr.exp)
    changeToExp match
      case Some(newExp: SchemeExp) =>
        addr.copy(exp = newExp)
      case _ =>
        addr

  // A value can be either annotated elements or elements. In both cases, we want to get all the values within the elements and update each of them
  def getNewValues(a: IncrementalGlobalStore[SchemeExp], value: a.Value): a.Value =
    value match
      case element: IncrementalSchemeTypeDomain.modularLattice.AnnotatedElements =>
        var newValues = element.values
        newValues= element.values.map(e => getNewValue(a, e))
        IncrementalSchemeTypeDomain.modularLattice.AnnotatedElements(newValues, element.sources).asInstanceOf[a.Value]
      case element: IncrementalSchemeTypeDomain.modularLattice.Elements =>
        val newElems = element.vs.map(e => getNewValue(a, e))
        IncrementalSchemeTypeDomain.modularLattice.Elements(newElems).asInstanceOf[a.Value]
     // case _ => value

  // If the value is a set of closures, we want to update both the lambda and enviroment within each closure (if necessary).
  // In case of a vector, we want to loop over each of the elements and update them each accordingly
  // If it is a set of pointers, each of the pointers might need updating. For this, getNewPointerAddr is used
  def getNewValue(a: IncrementalGlobalStore[SchemeExp], value:  Value): Value =
    value match
      case clos : IncrementalSchemeTypeDomain.modularLattice.Clo =>
        var newClos: Set[IncrementalSchemeTypeDomain.modularLattice.schemeLattice.Closure] = clos.closures.map(closure =>
          allExpressionsInChange.get(closure._1) match // check if lambda is in a change expression
            case Some(lambda: SchemeLambdaExp) =>
              closure._2 match // update the environment of the lambda if it needs changing
                case env : maf.core.BasicEnvironment[_] =>
                  var newEnv = createNewEnvironment(env)
                  (lambda, new BasicEnvironment[Address](newEnv))
               // case env: _ => (lambda, env)
            case _ => closure // Lambda doesn't exist in a change expression: nothing needs to change
        )
        IncrementalSchemeTypeDomain.modularLattice.Clo(newClos)
      case vector: IncrementalSchemeTypeDomain.modularLattice.Vec =>
        val newElementsVector = vector.elements.map((k, vecelem) =>
          val nw = getNewValues(a, vecelem.asInstanceOf[a.Value])
          (k, nw)
        )
        val newVector = IncrementalSchemeTypeDomain.modularLattice.Vec(size = vector.size, elements = newElementsVector.asInstanceOf[vector.elements.type])
        newVector
      case pointer: IncrementalSchemeTypeDomain.modularLattice.Pointer =>
        IncrementalSchemeTypeDomain.modularLattice.Pointer(pointer.ptrs.map(p => p match
          case pa: PtrAddr =>
            getNewPointerAddr(pa)
        //  case a: _ => a
        ))
      case cons: IncrementalSchemeTypeDomain.modularLattice.Cons =>
        (cons.car, cons.cdr) match
          case (car: a.Value, cdr: a.Value) =>
            val newcar = getNewValues(a, car).asInstanceOf[cons.car.type]
            val newcdr = getNewValues(a, cdr).asInstanceOf[cons.cdr.type]
            IncrementalSchemeTypeDomain.modularLattice.Cons(newcar, newcdr)
      case _ =>
        value

  // To create an new enviroment, loop over the old enviroment
  // If a variable did not change, it can be added to the new environment
  // If it did change, the variable that it changed into needs to be added to the environment
  def createNewEnvironment(oldEnv: maf.core.BasicEnvironment[_]): Map[String, Address] =
    var newEnv: Map[String, Address] = Map()
    oldEnv.content.foreach((k, v) =>
      v match
        case varAddr: VarAddr =>
          var oldIdn = varAddr.idn
          changedVars.find((k , v) => k.idn == oldIdn) match
            case Some(identifiers) =>
              newEnv += (identifiers._2.name -> varAddr.copy(id = identifiers._2))
            case _ => newEnv += (k -> v)
        case _ => newEnv += (k -> v))
    newEnv
}
